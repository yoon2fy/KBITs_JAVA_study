# Chapter 06 클래스
## 6.01 객체 지향 프로그래밍
- **객체(object):** 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것
- 속성(필드, field)와 동작(메소드, method)으로 구성됨
- **객체 지향 프로그래밍(Object Oriented Programming, OOP):** 객체 객체들을 먼저 만들고, 이 객체들을 하나씩 조립해서 프로그램을 만드는 기법

### 객체의 상호작용
- 객체들은 다른 객체와 **메소드**를 통해 서로 상호작용하면서 동작한다.
- **매개값:** 객체가 전달하고자 하는 데이터이며, 메소드 이름과 함께 괄호()안에 기술
- **리턴값:** 메소드의 실행의 결과이며, 호출한 곳으로 돌려주는 값

```java
메소드(매개값1, 매개값2, ...);
```

### 객체 간의 관계
- **집합 관계:** 완성품과 부품의 관계
- **사용 관계:** 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
- **상속 관계:** 부모와 자식 관계, 필드/메소드를 물려받음

### 객체 지향 프로그래밍의 특징
1. **캡슐화(Encapsulation):** 객체의 데이터(필드), 동작(메소드)을 하나로 묶고 실제 구현 내용을 외부에 감추는 것
2. **상속(Inheritance):** 부모 객체가 자기 필드와 메소드를 자식 객체에게 물려줘 자식 객체가 사용할 수 있게 함
  → 코드 재사용성 높이고 유지 보수 시간 최소화
4. **다형성(Polymorphism):** 사용 방법은 동일하지만 실행 결과가 다양함

## 6.02 객체와 클래스
### 클래스와 인스턴스
- 객체 지향 프로그래밍에서도 객체를 생성하려면 **설계도**에 해당하는 **클래스**가 필요
- 클래스로부터 생성된 객체를 해당 클래스의 **인스턴스**라고 부름
- 클래스로부터 객체를 만드는 과정을 **인스턴스화**라고 함
- 동일한 클래스로부터 여러 개의 인스턴스를 만들 수 있음

## 6.03 클래스 선언
- **클래스 선언:** 객체를 생성(**생성자**)하고, 객체가 가져야 할 데이터(**필드**)가 무엇이고, 객체의 동작(**메소드**)은 무엇인지를 정의
- 클래스 선언은 소스 파일명과 동일하게 작성
```java
// 클래스 선언
public class 클래스명 {
}
```

## 6.04 객체 생성과 클래스 변수
### 클래스 변수
- 클래스로부터 객체를 생성하려면 객체 생성 연산자인 new가 필요
- **new 연산자:** 객체를 생성시키고 객체의 주소를 리턴
- **라이브러스 클래스:** 실행할 수 없으며 다른 클래스에서 이용하는 클래스
- **실행 클래스:** main() 메소드를 가지고 있는 실행 가능한 클래스

## 6.05 클래스의 구성 멤버
- **필드:** 객체의 데이터를 저장하는 역할. 선언 형태는 변수 선언과 비슷하지만 쓰임새는 다름
- **생성자:** new 연산자로 객체를 생성할 때 객체의 초기화 역할. 선언 형태는 메소드와 비슷하지만, 리턴 타입이 없고 이름은 클래스 이름과 동일
- **메소드:** 객체가 수행할 동작으로 함수로도 불림

## 6.06 필드 선언과 사용
### 필드, Field
- 객체의 데이터를 저장하는 역할
- 객체 데이터: 고유 데이터, 현재 상태 데이터, 부품 데이터 등
- **필드 선언:** 필드는 클래스 블록에서 선언되어야 함
- **필드 사용:** 필드값을 읽고 변경하는 것

```java
// 📌 필드 선언 예시[Car.java]
public class Car {
  // 필드 선언
  String model = "그랜저"; // 고유 데이터 필드
  boolean start = true;    // 상태 데이터 필드
  int speed = 300;         // 상태 데이터 필드
}

// 📌 필드 사용 예시[CarExample.java]
public class CarExample {
  public static void main(String[] args){
    Car myCar = new Car(); // Car 객체 생성
    System.out.println("모델명: " + myCar.model); // Car 객체의 필드 사용
    myCar.speed = 60; // Car 객체의 필드값 변경
  }
}
```

- 초기값을 제공하지 않을 경우 필드는 객체 생성시 자동으로 기본값으로 초기화

**table.** 기본 타입의 데이터 타입별 기본값
|분류|데이터 타입|기본값|
|-|-|-|
|정수 타입|byte|0|
| |char|\u0000 (빈공백)|
| |short|0|
| |int|0|
| |long|0L|
|실수 타입|float|0.0F|
||double|0.0|
|논리 타입|boolean|false|

**table.** 참조 타입의 데이터 타입별 기본값
|분류|데이터 타입|기본값|
|-|-|-|
|참조타입|배열|null|
||클래스(String 포함)|null|
||인터페이스|null|

## 6.07 생성자 선언과 호출
### new 연산자
- 객체를 생성한 후 연이어 생성자(constructor)를 호출해서 객체를 초기화 함
- **객체 초기화:** 필드 초기화를 하거나 메서드를 호출해서 객체를 사용할 준비를 하는것.

```java
클래스 변수 = new 클래스();
```
### 기본 생성자
- 모든 클래스는 생성자가 존재하며, 하나 이상 가질 수 있음
- 클래스에 생성자 선언이 없으면, 컴파일러는 기본 생성자를 바이코코드 파일에 자동으로 추가

### 생성자 선언
- 객체를 다양하게 초기화하기 위해 생성자를 직접 선언할 수 있음
- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일
- 매개변수 타입은 매개값의 종류에 맞게 작성

```java
public class Car {
  // 📌 생성자 선언
  Car(String model, String color, int maxSpeed){ 
    실행문;
  }
}
Car myCar = new Car("그랜저", "검정", 300);
```

### 필드 초기화
- 객체마다 동일한 값을 갖고 있다면 필드 선언 시 초기값을 대입하는 것이 좋음
- 객체마다 다른 값을 가져야 한다면 생성자에서 필드를 초기화하는 것이 좋음

```java
public class Korean {
  // 📌 필드 선언
  String nation = "대한민국";
  String name;
  String ssn;


  // 📌 생성자 선언 -- 필드를 초기화 하는 역할을 함.
  public Korean(){
    name = n;
    ssn = s;
  }
}
```

### 생성자에서의 변수 명
- 지역변수와 필드 변수명이 동일한 경우 지역변수로 해석
- 서로 다른 이름을 부여하는 경우, 변수명 관리가 힘들어짐
- **this:** 현재 인스턴스에 대한 참조 변수로 this.변수명으로 필드 변수에 접근 가능함

### 생성자 오버로딩
- 매개변수를 달리하는 생성자를 여러 개 선언하는 것

```java
public class Car {
  Car(){ ... }
  Car(String model){ ... }
  Car(String model, String color){ ... }
  Car(String model, String color, int maxSpeed){ ... }
}
```

- 매개변수의 타입, 개수, 순서가 똑같을 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아님.

```java

Car(){}
Car(){} // 오버로딩이 아님. 컴파일 에러가 발생함.
```

- 생성자가 오버로딩되어 있을 경우, **new 연산자**로 생성자를 호출할 때, 제공되는 매개값의 타입과 수에 따라 실행될 생성자가 결정됨.

```java
Car car1 = new Car();                      // Car(){ ... }
Car car2 = new Car("그랜저");              // Car(String model){ ... }
Car car3 = new Car("그랜저", "흰색");      // Car(String model, String color){ ... }
Car car4 = new Car("그랜저", "흰색", 300); //Car(String model, String color, int maxSpeed){ ... }
```

### 다른 생성자 호출
- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있음
- 이 경우 공통 코드를 한 생성자에만 집중적으로 작성 (e.g. *this(model, "은색", 250);*)
- 나머지 생성자는 this (...)를 사용해 공통 코드를 가진 생성자를 호출

## 6.08 메소드 선언과 호출
### 메소드 선언
- 객체의 동작을 실행 블록으로 정의하는 것
- **리턴 타입:** 메소드 실행 후 호출한 곳으로 전달하는 결과값의 타입
  - void: 리턴값이 없는 메소드 선언
  - double: double 타입 값을 리턴하는 메소드 선언
- **메소드명:** 메소드명은 첫 문자를 소문자로 시작하고, 캐멀 스타일로 작성
- **매개변수:** 메소드를 호출할 때 전달한 매개값을 받기 위해 사용
- **실행 블록:** 메소드 호출 시 실행되는 부분

```java
리턴타입 메소드명(매개변수, ...){
  실행문;
}
```

### 메소드 호출
- 메소드 블록을 실제로 실행하는 것
- 클래스로부터 객체가 생성된 후에 메소드는 생성자와 다른 메소드 내부에서 호출될 수 있고, 객체 외부에서도 호출될 수 있음.
- 외부 객체에서는 참조 변수와 도트(.)연산자로 호출

```java
public class Calculator {
  // 📌 리턴값이 없는 메소드 선언
  void powerOn(){} 

  // 📌 리턴값을 받는 메소드 선언
  int plus(int x, int y){ 
    int result = x + y;
    return result; // 리턴값 지정
  }
}
```

### 가변길이 매개변수
- 메소드가 가변길이 매개변수를 가지고 있다면 매개변수의 개수와 상관없이 매개값을 줄 수 있음
```java
int sum (int...valuse){
}

int result = sum(1,2,3);
int result = sum (1,2,3,4,5);
```

- 메소드 호출 시 매개값을 쉼표로 구분해서 개수와 상관없이 제공할 수 있음
- 매개값들은 자동으로 배열 항목으로 변환되어 메소들에서 사용됨
```java
int[] values = {1,2,3};
int result = sum(values);
int result = sum(new int[] {1,2,3});
```

### return문
- 메소드의 실행을 강제 종료하고 호출한 곳으로 돌아간다는 의미
- 메소드 선언에 리턴 타입이 있을 경우에는 return문 뒤에 리턴값을 추가로 지정해야 함
- return문 이후에 실행문을 작성하면 *'Unreachable code'* 라는 컴파일 에러가 발생함

```java
return 리턴값;
```

### 메소드 오버로딩
- 메소드 이름은 같되, 매개변수의 타입/개수/순서가 다른 메소드를 여러개 선언하는 것

## 6.09 인스턴스 멤버
**table.** 선언 방법에 따른 멤버의 구분
|구분|설명|
|-|-|
|인스턴스(instance) 멤버| 객체에 소속된 멤버 (객체를 생성해야만 사용할 수 있는 멤버)|
|정적(static) 멤버|클래스에 고정된 멤버 (객체 없이도 사용할 수 있는 멤버)|

### this 키워드
- 객체 내부에서는 인스턴스 멤버에 접근하기 위해 this를 사용.
- 객체는 자신을 'this'라고 지칭
- 생성자와 메소드의 매개변수명이 인스턴스 멤버인 필드명과 동일한 경우, 인스턴스 필드임을 강조하고자 할 때 this를 주로 사용

## 6.10 정적 멤버
### 정적 멤버 선언
- **static** 키워드를 추가해 정적 필드와 정적 메소드로 선언

### 정적 멤버 사용
- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있음
- 클래스 이름과 함께 도트(.) 연산자로 접근
- 정적 필드와 정적 메소드는 객체 참조 변수로도 접근

## 6.11 final 필드와 상수
### final 필드 선언
- final 필드는 **초기값**이 **저장**되면 **최종적인 값**이 되어서 프로그램 실행 도중에 수정할 수 없게 됨
- final 필드 초기화: (1) 필드 선언 시에 초기값을 대입, (2) 생성자에서 초기값을 대입

## 6.12 패키지
### 자바의 패키지
- 클래스의 일부분이며, 클래스를 식별하는 용도
- 패키지는 주로 개발 회사의 도메인 이름의 역순으로 만듦
- 상위 패키지와 하위 패키지를 도트(.)로 구분
- 패키지에 속한 바이트코드 파일(~.class)은 따로 떼어내어 다른 디렉토리로 이동할 수 없음
  
### 패키지 선언
- 패키지 선언은 package 키워드와 함께 패키지 이름을 기술한 것.
- 항상 소스 파일 최상단에 위치
- 패키지 이름은 모두 소문자로 작성.
- 패키지 이름이 서로 중복되지 않도록 회사 도메인 이름의 역순으로 작성하고, 마지막에는 프로젝트 이름을 붙여줌

### import문
- 다른 패키지에 있는 클래스를 사용하려면 import문으로 어떤 패키지의 클래스를 사용하는지 명시
- import문은 패키지 선언과 클래스 선언 사이에 작성
- import 키워드 뒤에는 사용하고자 하는 클래스의 전체 이름을 기술

### 다른 패키지에 있는 동일 이름의 클래스를 사용하기
- 이름 충돌 때문에 import문을 사용할 수 없다.

## 6.13 접근 제한자
- 중요한 필드와 메소드가 외부로 노출되지 않도록, **객체의 무결성을 유지**하기 위해서 접근 제한자 사용

**table.** 접근 제한자의 종류
|접근 제한자|제한 대상|제한범위|접근 제한|
|-|-|-|-|
|public|클래스, 필드, 생성자, 메소드|없음|약한 제한|
|protected|필드, 생성자, 메소드|같은 패키지이거나, 자식 객체만 사용 가능||
|(default)|클래스, 필드, 생성자, 메소드|같은 패키지||
|private|필드, 생성자, 메소드|객체 내부|강한 제한|

### 클래스의 접근 제한
- 클래스를 선언할 때 public 접근 제한자를 생략하면 클래스는 다른 패키지에서 사용할 수 없음
- 클래스를 선언할 때 public 접근 제한자를 붙이면 클래스는 같은 패키지 뿐만 아니라 다른 패키지에서도 사용할 수 있음

### 생성자의 접근 제한
- 생성자는 public, default, private 접근 제한을 가질 수 있음

**table.** 접근 제한자의 종류
|접근 제한자|생성자|설명|
|-|-|-|
|public|클래스(...)|모든 패키지에서 생성자를 호출할 수 있다. (= 모든 패키지에서 객체를 생성할 수 있다.)|
|(default)|클래스(...)|같은 패키지에서 생성자를 호출할 수 있다. (= 같은 패키지에서 객체를 생성할 수 있다.)|
|private|클래스(...)|클래스 내부에서만 생성자를 호출할 수 있다. (= 클래스 내부에서만 객체를 생성할 수 있다.)|

## 6.14 Getter와 Setter
### 객체의 필드(데이터) 은닉
- 외부에서 직접 접근하는 경우 잘못된 데이터 입력 가능 -- 객체의 무결성(결점이 없는 성질)이 깨짐.
- private 또는 default 접근 제한자로 보호함.

- **Setter 메서드:** 데이터를 검증해서 유효한 값만 필드에 저장하는 메소드
- **Getter 메서드:** 필드값이 객체 외부에서 사용하기에 부적절한 경우, 적절한 값으로 변환해서 리턴할 수 있는 메소드

```java
private double speed;

// Setter 메서드의 사례
public void setSpeed(double speed){
  if(speed < 0){
    this.speed = 0;
    return;
  } else {
      this.speed = speed;
  }
}

// Getter 메서드의 사례
public double getSpeed(){
  double km = speed*1.6;
  return km;
}
```

- **필드에 대한 접근**은 **Getter, Setter 메서드**로 접근

```java
private 타입 fieldName;      // 📌 필드 접근 제한자: private

// Getter
// 📌 접근 제한자: public, 리턴 타입: 필드타입, 메소드 이름: get + 필드이름(첫 글자 대문자), 리턴값: 필드값
public 타입 getFieldName(){
  return fieldName;
}

// Setter
// 📌 접근 제한자: public, 리턴 타입: void, 메소드 이름: set + 필드이름(첫 글자 대문자), 매개변수 타입: 필드타입
public void setFieldName(타입 fieldName){
  this.fieldName = fieldName;
}
```

- **boolean** 타입에 대한 Getter 메서드는 **isXxxx()**가 관례

```java
private boolean stop;      // 📌 필드 접근 제한자: private

// Getter
// 📌 접근 제한자: public, 리턴 타입: 필드타입, 메소드 이름: is + 필드이름(첫 글자 대문자), 리턴값: 필드값
public boolean isStop(){
  return stop;
}
```

### Getter, Setter 자동 생성
- IDE에서 자동 생성 기능 제공함.

## 6.15 싱글톤 패턴
### 싱글톤(Singleton) 패턴
- **생성자를 private 접근 제한** 해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아서 외부에서 마음대로 객체를 생성하지 못하게 함
- 대신 싱글톤 패턴이 제공하는 **정적 메소드를 통해 간접적으로 객체를 얻을 수 있음**

```java
// 첫 번째 사례
public class 클래스 {
  private static 클래스 singleton = new 클래스(); // 📌 public 접근 권한을 갖는 정적 필드 선언과 초기화
  private 클래스(){}                              // 📌 public 접근 권한을 갖는 생성자 선언
  public static 클래스 getInstance(){             // 📌 public 접근 권한을 갖는 정적 메소드 선언
    return singleton;
  }
}

// 두 번째 사례
public class 클래스 {
  public static void main(String[] args){
    Singleton obj1 = Singleton.getInstance();     // 📌 정적 메소드를 호출해서 싱글톤 객체 얻음
    Singleton obj2 = Singleton.getInstance();
  }
}

```
