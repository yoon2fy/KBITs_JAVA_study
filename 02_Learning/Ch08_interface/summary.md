# Chapter 08 인터페이스
## 8.01 인터페이스의 역할
- **인터페이스(interface):** 두 객체를 연결하는 역할. 다형성 구현에 주된 기술.

## 8.02 인터페이스와 구현 클래스 선언
### [1] 인터페이스 선언 (추상 메소드 선언)
- 인터페이스 선언은 **class 키워드** 대신 **interface 키워드**를 사용
- **접근 제한자:** default, public

```java
interface 인터페이스명 { ... }        // default 접근 제한
public interface 인터페이스명 { ... } // public 접근 제한
```

### [2] 구현 클래스 선언
- 인터페이스에 정의된 추상 메소드에 대한 실행 내용이 구현
- **implements** 키워드는 해당 클래스가 인터페이스를 통해 사용할 수 있다는 표시이며,
- 인터페이스의 추상 메소드를 재정의한 메소드가 있다는 뜻

```java
public class B implements 인터페이스명 { ... }
```

### [3] 변수 선언과 구현 객체 대입
- 인터페이스를 통해 구현 객체를 사용하려면, 인터페이스 변수에 구현 객체의 번지를 대입해야 함

```java
RemoteControl rc;      // 📌 추상 메소드 변수 선언
rc = new Television(); // 📌 구현 객체 대입
```

## 8.03 상수 필드
- 인터페이스는 public static final 특성을 갖는 **불변의 상수 필드**를 멤버로 가질 수 있음
- public static final 생략 가능
- 상수명 표기법: (1) 대문자, (2) Snake 표기법

```java
[public static final] 타입 상수명 = 값;
```

## 8.04 추상 메소드
- **추상 메소드 (abstract method):** 객체에 대해 메소드 선언부만 작성을 함
- 리턴 타입, 메소드명, 매개변수만 기술되고 **중괄호 { }를 붙이지 않는** 메소드
- 인터페이스 = 필드 + 추상메소드(= **재정의**)

## 8.05 디폴트 메소드
- 인터페이스에는 완전한 실행 코드를 가진 디폴트 메소드를 선언할 수 있음
- **추상 메소드와의 차이점:** (1) 실행부가 있음(중괄호 {}), (2) **default** 키워드가 있음

```java
[public] default 리턴타입 메소드명(매개변수, ... ){ ... }
```

## 8.06 정적 메소드
- **정적 메소드(static method):** 구현 객체가 없어도 인터페이스만으로 호출됨.
- **선언 방법:** 클래스 정적 메소드와 완전 동일하다. 단, public을 생략하더라도 자동으로 컴파일 과정에서 붙는 것이 차이점임.
- 선언된 정적 메소드는 구현 객체 없이 인터페이스명으로 접근해서 호출할 수있음.

```java
[public | private] static 리턴타입 메소드명(매개변수, ... ){ ... }
```

## 8.07 private 메소드
- **private 메소드:** 인터페이스에 외부에서 접근할 수 없음. 디폴트와 정적 메소드들의 **중복 코드를 줄이기 위해** 사용됨.
- 인터페이스의 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드는 모두 **public** 접근 제한을 가짐
- private 메소드는 디폴트 메소드 안에서만 호출이 가능
- private 정적 메소드는 정적 메소드 안에서도 호출이 가능

**table.** private 메소드의 종류
|구분|설명|
|-|-|
|private 메소드|구현 객체가 필요한 메소드|
|private 정적 메소드|구현 객체가 필요 없는 메소드|

## 8.08 다중 인터페이스 구현
- 구현 객체는 여러개의 인터페이스를 implements할 수 있다.

```java
public class 구현클래스명 implements 인터페이스A, 인터페이스B {
  // 모든 추상메소드 재정의
}
```

## 8.09 인터페이스 상속
- 인터페이스도 다른 인터페이스를 상속할 수 있음. **(다중 상속 허용)**
- **extends** 키워드 뒤에 상속할 인터페이스들을 나열
- 자식 인터페이스의 구현 클래스는 자식 인터페이스의 메소드뿐만 아니라 부모 인터페이스의 모든 **추상 메소드를 재정의** 해야함. 

```java
public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 { ... }

// 📌 추상메소드 재정의
자식인터페이스 변수 = new 구현클래스 {...};
부모인터페이스1 변수 = new 구현클래스 {...};
부모인터페이스2 변수 = new 구현클래스 {...};
```

## 8.10 타입 변환
### [1] 자동 타입 변환
- 자동으로 타입 변환이 일어나는 것.
- 부모 클래스가 인터페이스를 구현하고 있다면 자식 클래스도 인터페이스 타입으로 자동 타입 변환될 수 있음

### [2] 강제 타입 변환
- 캐스팅 기호를 사용해서 인터페이스 타입을 구현 클래스 타입으로 변환시키는 것.
- 구현 객체가 인터페이스 타입으로 자동 변환되면, 인터페이스에 선언된 메소드만 사용 가능함.

## 8.11 다형성
### [1] 다형성
- 사용 방법은 동일하지만 다양한 결과가 나오는 성질
- 인터페이스 역시 다형성을 구현하기 위해 재정의와 자동 타입 변환 기능을 이용

### [2] 매개변수의 다형성
- 매개변수 타입을 인터페이스로 선언
- 메소드 호출 시 다양한 구현 객체를 대입할 수 있음

## 8.12 객체 타입 확인
- **instanceof 연산자:*-* 인터페이스에서 객체 타입을 확인하기 위해 사용

```java
if (vehicle instanceof Bus){
  // vehicle에 대입된 객체가 Bus인 경우 실행
}
```

## 8.13 봉인된 인터페이스
- **봉인된(sealed) 인터페이스:** 무분별한 자식 인터페이스 생성을 방지하기 위해 사용됨
- **sealed** 키워드를 사용하면 permits 키워드 뒤에 상속 가능한 자식 인터페이스를 지정해야함.
- **non-sealed** 키워드를 사용하면 봉인을 해제한다는 뜻임.

```java
public sealed interface InterfaceA permits InterfaceB { ... }
public non-sealed interface InterfaceA extends InterfaceB { ... }
```
