# Chapter 07 상속
## 7.01 상속 개념
### 상속(Inheritance)
- 클래스를 만들 때 기존에 있던 클래스를 이용해 확장해 만드는 것
- 기존 클래스를 **재사용**
- 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있음

### 개념의 크기
- **is-a 관계:** 자식이 부모이다.
- **부모/상위클래스:** Parent Class, Super Class
- **자식/하위클래스:** Child Class, Sub Class

### 상속의 이점
- 이미 개발된 클래스를 재사용하므로 중복 코드를 줄임
- 클래스 수정을 최소화함

## 7.02 클래스 상속
- 자식 클래스를 선언할 때 어떤 부모로부터 상속받을 것인지를 결정하고, 부모 클래스를 다음과 같이 **extends* 뒤에 기술
- 다중 상속 허용하지 않음. extends 뒤에 하나의 부모 클래스만 상속

```java
public class 자식클래스 extends 부모클래스 {
}
```

## 7.03 부모 생성자 호출
- 자식 객체를 생성하면 부모 객체가 먼저 생성된 다음에 자식 객체가 생성해야함.
- 부모의 생성자를 먼저 호출하게 함. **super();**, **super(필드, 필드);**
- 부모 생성자는 자식 생성자의 맨 첫 줄에 숨겨져 있는 super()에 의해 호출

```java
public 자식클래스(...){
  super(매개값, ...)
}
```

## 7.04 메소드 재정의
### 메소드 오버라이딩(Method Overriding)
- **메소드 오버라이딩:** 상속된 메소드를 자식 클래스에서 **재정의**하는 것.
- 해당 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용
- 부모 메소드의 선언부 **(리턴 타입, 메소드 이름, 매개변수)와 동일해야** 함 → 완전히 같아야함.
- 접근 제한을 더 강하게 오버라이딩할 수 없음(public → private으로 변경 불가)
- 새로운 예외를 throws할 수 없음

### 부모 메소드 호출
- 자식 메소드 내에서 super 키워드와 도트(.) 연산자를 사용하면 숨겨진 부모 메소드를 호출
- 부모 메소드를 재사용함으로써 자식 메소드의 중복 작업 내용을 없애는 효과

## 7.05 final 클래스와 final 메소드
### final 클래스
- **상속 불가능한 클래스**
- final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없음

```java
public final class 클래스 {...}
```

### final 메소드
- **재정의(오버라이드) 불가능 메서드**
- 메소드를 선언할 때 final 키워드를 붙이면 오버라이딩할 수 없음
- 부모 클래스를 상속해서 자식 클래스를 선언할 때, 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없음

```java
public final 리턴타입 메소드(매개변수, ...){...}
```

## 7.06 protected 접근 제한자
- protected는 상속과 관련이 있고, public과 default의 중간쯤에 해당하는 접근 제한
- protected는 **같은 패키지**에서는 **default**처럼 접근이 가능하나, **다른 패키지**에서는 **자식 클래스만 접근을 허용**

|접근 제한자|제한 대상|제한 범위|
|-|-|-|
|protected|필드, 생성자, 메소드|같은 패키지이거나 자식 객체만 사용 가능|

## 7.07 타입 변환
- **타입 변환:** 타입을 다른 타입으로 변환하는 것
- **자동 타입 변환(promotion):** 자동적으로 타입 변환이 일어나는 것
- (부모타입 변수) = (자식타입 객체);
  
```java
Cat cat = new cat();
Animal animal = cat;

cat == animal // cat과 animal 변수는 타입만 다를 뿐 동일한 Cat 객체를 참조한다.
```

---
여기까지 작성중


## 7.08 다형성


## 7.09 객체 타입 확인


## 7.10 추상 클래스


## 7.11 봉인된 클래스





