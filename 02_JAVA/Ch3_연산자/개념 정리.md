# Chapter 03 연산자
## 3.01. 부호/증감 연산자
**table.** 부호/증감 연산자
| No. | 연산식 | 설명 |
|-|-|-|
| 01 | +i | i의 부호를 유지한다. |
| 02 | -i | i의 부호를 변경한다. |
| 03 | ++i | i의 값을 1 증가 시킨다. |
| 04 | --i | i의 값을 1 감소 시킨다. |
| 05 | i++ | 다른 연산을 수행한 후에, i의 값을 1 증가 시킨다.|
| 06 | i-- | 다른 연산을 수행한 후에, i의 값을 1 감소 시킨다.|

## 3.02. 산술 연산자
- 피연산자가 정수 타입(byte, short, char, int)이면 연산의 결과는 int 타입이다.
- 피연산자가 정수 타입이고, 그 중 하나가 long 타입이면 연산의 결과는 long 타입이다.
- 피연산자 중 하나가 실수 타입이면 연산의 결과는 실수 타입이다.

**table.** 산술 연산자
| No. | 연산식 | 설명 |
|-|-|-|
| 01 | + | 덧셈 연산 |
| 02 | - | 뺄셈 연산 |
| 03 | * | 곱셈 연산 |
| 04 | / | 나눗셈 연산 |
| 05 | % | 나눗셈의 나머지를 산출하는 연산 |

## 3.03. 오버플로우와 언더플로우
- **오버플로우(overflow):** 타입이 허용하는 최대값을 벗어나는 것.
- **언더플로우(underflow):** 타입이 허용하는 최소값을 벗어나는 것.
- 만약, 연산 과정에서 int 타입에서 오버/언더플로우가 발생될 가능성이 있다면, long 타입으로 연산을 하도록 해야한다.

## 3.04. 정확한 계산은 정수 연산으로
- 산술 연산을 정확하게 계산하고 싶다면 실수 타입을 사용하지 않는 것이 좋다.

## 3.05. 나눗셈 연산 후 NaN과 Infinity 처리
- i/0, i%0은 예외(ArithmeticException)가 발생할 수 있다. 무한대의 값을 정수로 표현할 수 없기 때문이다.
- 하지만, 0.0 또는 0.0f이면 Infinity 또는 NaN(Not a Number)이 된다.

## 3.06. 비교 연산자
- 문자열이나 객체를 비교할 때는 동등 연산자(==, !=) 대신 **equals()** 와 **!equals()** 를 사용함.

**table.** 비교 연산자
| No. | 연산식 | 설명 |
|-|-|-|
| 01 | == | 같다 |
| 02 | != | 다르다 |
| 03 | > | 크다 |
| 04 | >= | 크거나 같다 |
| 05 | < | 작다 |
| 06 | <= | 작거나 같다 |

## 3.07. 논리 연산자
**table.** 논리 연산자
| No. | 구분 | 연산식 | 설명 |
|-|-|-|-|
| 01 | AND (논리곱) | &&, & | 피연산자 모두가 TRUE일 때만 연산 결과가 TRUE |
| 02 | OR (논리합) | \\, \ | 피연산자중 하나면 TRUE이면 연산 결과는 TRUE |
| 03 | XOR (베타적 논리합) | ^ | 피연산자가 하나는 TRUE이고 다른 하나가 FALSE인 경우에만 연산 결과가 TRUE |
| 04 | NOT (논리 부정) | ! | 피연산자의 논리값을 바꿈 |

**table.** 논리 연산자의 경우의 수
| A | 연산식 | B | = | 결과 |
|-|-|-|-|-|
| T | && | T | = | T |
| T | && | F | = | F |
| F | && | T | = | F |
| F | && | F | = | F |
| T | \\ | T | = | T |
| T | \\ | F | = | T |
| F | \\ | T | = | T |
| F | \\ | F | = | F |
| T | ^ | T | = | F |
| T | ^ | F | = | T |
| F | ^ | T | = | T |
| F | ^ | F | = | F |
|  | ! | T | = | F |
|  | ! | F | = | T |

## 3.08. 비트 논리 연산자
**table.** 비트 연산자
| No. | 구분 | 연산식 | 설명 |
|-|-|-|-|
| 01 | AND (논리곱) | & | 두 비트 모두 1일 경우에만 연산 결과가 1 |
| 02 | OR (논리합) | \ | 두 비트중 하나만 1이면 연산 결과는 1 |
| 03 | XOR (베타적 논리합) | ^ | 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1 |
| 04 | NOT (논리 부정) | ~ | 보수 |

**table.** 비트 연산자의 경우의 수
| A | 연산식 | B | = | 결과 |
|-|-|-|-|-|
| 1 | & | 1 | = | 1 |
| 1 | & | 0 | = | 0 |
| 0 | & | 1 | = | 0 |
| 0 | & | 0 | = | 0 |
| 1 | \ | 1 | = | 1 |
| 1 | \ | 0 | = | 1 |
| 0 | \ | 1 | = | 1 |
| 0 | \ | 0 | = | 0 |
| 1 | ^ | 1 | = | 0 |
| 1 | ^ | 0 | = | 1 |
| 0 | ^ | 1 | = | 1 |
| 0 | ^ | 0 | = | 0 |
|  | ~ | 1 | = | 0 |
|  | ~ | 0 | = | 1 |

## 3.09. 비트 이동 연산자
- **비트 이동(shift) 연산자:** 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

**table.** 비트 이동 연산자
| No. | 연산식 | 설명 |
|-|-|-|
|01|<<|정수 a의 각 비트를 b만큼 왼쪽으로 이동. 오른쪽 빈자리는 0으로 채움. a*(2^b)와 동일한 결과가 됨.|
|02|>>|정수 a의 각 비트를 b만큼 오른쪽으로 이동. 왼쪽 빈자리는 최상위 부로 비트와 같은 값으로 채움. a/(2^b)와 동일한 결과가 됨.|
|03|>>>|정수 a의 각 비트를 b만큼 오른쪽으로 이동. 왼쪽 빈자리는 0으로 채움.|

## 3.10. 대입 연산자
- **대입 연산자:** 는 우측 피연산자의 값을 좌측 피연산자인 변수에 대입한다.
- **단순 대입 연산자:** 는 단순히 값을 대입한다.
- **복합 대입 연산자:** 는 정해진 연산을 수행한 후 결과를 대입한다.

**table.** 단순 대입 연산자
| 연산식 | 설명 |
| ----- | - |
| a = b | 변수 a에 피연산자 b값을 저장함. |  

**table.** 복합 대입 연산자
| 연산식 | 설명 |
| ------ | - |
| a += b | a = a + b |
| a -= b | a = a - b |
| a *= b | a = a * b |
| a /= b | a = a / b |
| a %= b | a = a % b |
| a &= b | a = a & b |
| a != b | a = a ! b |
| a ^= b | a = a ^ b |
| a <<= b | a = a << b |
| a >>= b | a = a >> b |
| a >>>= b | a = a >>> b |

## 3.11. 삼항(조건) 연산자
- **삼항 연산자:** A ? B : C
- A가 True이면 B를 반환하고, A가 False이면 C를 반환한다.

## 3.12. 연산의 방향과 우선순위
- 연산자는 우선순위가 정해져 있으며, 우선순위가 같은 경우에는 연산의 방향에 따라 달라진다.
- 잘 모르겠으면, 먼저 처리해야할 연산을 괄호()로 묶으면 된다.

**table.** 연산의 방향과 우선순위 → ←
| 연산자 | 연산 방향 | 우선순위 |
|-|-|-|
| 증감(++, --), 부호(+,-), 비트(~), 논리(!) | ← | 높음 |
| 산술(*, /, %) | → | |
| 산술(+, -) | → | |
| 쉬프트(<<, >>, >>>) | → | |
| 비교(<, >, <=, >=, instancedof) | → | |
| 비교(==, !=) | → | |
| 논리(&) | → | |
| 논리(^) | → | |
| 논리(!) | → | |
| 논리(&&) | → | |
| 논리(||) | → | |
| 조건(?:) | → | |
| 대입(=, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=)| ← | 낮음 |
