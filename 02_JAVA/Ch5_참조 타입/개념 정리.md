# Chapter 05 참조타입
## 5.01 데이터 타입 분류
- **데이터 타입:** 은 기본 타입(primitive type)과 참조 타입(reference type)으로 분류된다.
- **참조타입:** 은 객체(object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입이 있다.
- **객체:** 데이터(필드)와 메소드로 구성된 덩어리이다.

### 📌 기본타입과 참조타입의 차이점
- **기본 타입으로 선언된 변수:** 값 자체를 저장
- **참조 타입으로 선언된 변수:** 객체가 생성된 **메모리 번지**를 저장

## 5.02 메모리 사용 영역
- JVM은 운영체제에서 할당받은 **메모리 영역 (Runtime Data Area)** 을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용

### 📌 메소드(Method) 영역
바이트코드 파일을 읽은 내용이 저장되는 영역

### 📌 힙(Heap) 영역
객체가 생성되는 영역. 객체의 번지는 메소드 영역과 스택 영역의 상수와 변수에서 참조

### 📌 스택(Stack) 영역
메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역

## 5.03 참조 타입 변수의 ==, != 연산
- ==, != 연산자는 객체의 **번지**를 비교해 변수의 값이 같은지, 아닌지를 조사
- 번지가 같다면 동일한 객체를 참조하는 것이고, 다르다면 다른 객체를 참조하는 것

## 5.04 null과 NullPointerException
### 📌 null값
- **참조 타입 변수**는 아직 **번지를 저장하고 있지 않다**는 뜻
- null도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 **스택 영역에 생성**
- null 값의 사용 기존 값을 가진 상태에서 null을 대입하면 기존 값은 사용 불가 상태가 됨(쓰레기, garbage)

### 📌 NullPointerException
- **예외(Exception):** 프로그램 실행 도중에 발생하는 오류
- **NullPointerException:** 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 때 발생하는 예외로, 참조 변수가 객체를 정확히 참조하도록 번지를 대입해야 해결됨.

### 📌 Garbage Collector
- 더 이상 사용하지 않는 메모리 영역(garbage)을 회수 하는 역할
- 자바 가상 머신이 주기적으로 실행
- 개발자는 메모리 회수에 신경쓸 필요 없음!

## 5.05 문자열(String) 타입
### 📌 String 타입
- **문자열**은 **String 객체**로 생성

**table.** 문자열 비교 함수 정리
| 메소드 | 설명 |
|-|-|
|==|참조가 같은지 검증|
|equals()|내부 문자열이 같은지 검증|
|charAt()|문자열에서 특정 위치의 문자를 얻음|
|length()|문자열에서 문자의 개수를 얻음|
|replace("x", "y")|문자열x를 문자열y로 대체함|
|substring(x)|x에서 끝까지 잘라냄|
|substring(x, y)|x에서 y앞까지 잘라냄|
|indexOf()|문자열에서 특정 문자열의 위치를 찾음|
|contains()|포함여부 결과만 알고 싶은 경우|
|split()|문자열을 분리함|

## 5.06 배열(Array) 타입
- 배열은 **힙 영역**에 생성되고 배열 변수는 힙 영역의 배열 주소를 저장함.
- 참조할 배열이 없다면 배열 변수도 null로 초기화할 수 있음.

```java
// 📌 첫 번째 방법
타입[] 변수 = {값0, 값1, 값2, 값3, ... };

// 📌 두 번째 방법
타입[] 변수;
변수 = new 타입 {값0, 값1, 값2, 값3, ... };
```

## 5.07 다차원 배열
- 배열 항목에는 또 다른 배열이 대입된 배열

```java
// 📌 값 목록으로 다차원 배열을 생성
타입[][] 변수 = {
  { 값1, 값2, ... }, // 📌 1차원 배열의 0번째 인덱스
  { 값3, 값4, ... }, // 📌 1차원 배열의 1번째 인덱스
  ...
};

// 📌 각 차원의 항목에 접근
변수[1차원인덱스][2차원인덱스]...[n차원인덱스]
```

## 5.08 객체를 참조하는 배열

### 배열에서 객체 참조하기
- **기본 타입 배열:** 각 항목에 값을 직접 저장
- **참조 타입 배열:** 각 항목에 객체의 **번지**를 저장

## 5.09 배열 복사
### 변수의 복사
### 📌 기본형 변수
- cpu가 변수에 들어있는 데이터를 다른 변수에 복사하여 대입

```java
int x = 10;
int y = x; // x== y
```
### 📌 참조형 변수
- **얕은 복사:** 주소를 복사함
- **깊은 복사:** 주소가 가리키는 값목록을 복사함

```java
// 📌 얕은 복사
int [] x = {1, 2};
int [] y = x; // x==y

// 📌 깊은 복사
int [] x = {1, 2};
int [] y = x.clone(); // x != y
```

### 배열의 복사
- 배열은 한 번 생성하면 길이를 변경할 수 없음.
- 더 많은 저장 공간이 필요하다면 더 큰 길이의 배열을 새로 만들고 이전 배열로부터 항목들을 복사함.

**table.** 배열 복사 방법 (깊은 복사)
|No.|방법|장점|단점|
|-|-|-|-|
|01|System.arraycopy()|실행 속도가 빠름, 시스템 레벨 최적화|시작/끝 인덱스 조절 필요, 배열 타입 일치 필요|
|02|Array.copyOf()|사용이 간단함, 부분 복사와 크기 조절이 가능|전체 배열 복사 시에만 효율적, 배열 타입 자동으로 일치|
|03|clone()|매우 간단한 구현|얕은 복사만 수행, 객체 배열에서 문제 발생 가능|
|04|반복문 사용|조건에 따른 복사 가능, 가장 명시적인 방법|코드가 길어질 수 있음, 수동 최적화 필요|

```java
// 📌 방법 01
System.arraycopy(src, 0, dest, 0, length);

// 📌 방법 02
int [] b = Arrays.copyOf(a, a.length);

// 📌 방법 03
int [] b = a.clone();

// 📌 방법 04
for (int i=0; i<a.length; i++){
  b[i] = a[i];
}
```

## 5.10 배열 항목 반복을 위한 향상된 for문
- **카운터 변수와 증감식을 사용하지 않고,** 항목의 개수만큼 반복한 후 자동으로 for 문을 빠져나감

```java
for (타입 변수 : 배열) {
  실행문;
}
```
- for 문이 실행이 되면, **배열**에서 가져올 항목이 있을 경우 **변수**에 항목을 저장한 다음 **실행문**을 실행함.
- 다시 반복해서 **배열**에서 가져올 다음 항목이 존재하면, **변수-실행문-배열**로 진행함.
- 가져올 다음 항목이 없으면, for문을 종료함.

## 5.11 main() 메소드의 String[] 매개변수 용도
### String[] args 매개변수의 필요성
- 자바 프로그램을 실행하기 위해 main() 메소드를 작성하면서 문자열 배열 형태인 String[ ] args 매개변수가 필요
- 프로그램 실행 시 입력값이 부족하면 길이가 0인 String 배열 참조


---
여기까지 함


## 5.12 열거(Enum) 타입


